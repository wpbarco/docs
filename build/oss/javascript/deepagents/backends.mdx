---
title: Backends
description: Choose and configure filesystem backends for deep agents, route paths, implement virtual filesystems, and enforce policies.
---

Deep agents expose a filesystem surface to the model via tools like `ls`, `read_file`, `write_file`, `edit_file`, `glob`, and `grep`. These tools operate through a pluggable backend. This page explains how to choose a backend, route different paths to different backends, implement your own virtual filesystem (for example, S3 or Postgres), add policy hooks, and comply with the backend protocol.

## Quick start

- Default (ephemeral in state):
  - `agent = create_deep_agent()`
- Local filesystem persistence:
  - `agent = create_deep_agent(backend=FilesystemBackend(root_dir="."))`
- Durable store (LangGraph Store):
  - `agent = create_deep_agent(backend=lambda rt: StoreBackend(rt))`
- Composite (ephemeral by default, `/memories/` persisted):
  - See Composite routing below for a ready‑to‑paste example.

## Built‑in backends

### StateBackend (ephemeral)
- Stores files in LangGraph agent state for the current thread; persists across turns via checkpoints.
- Best for scratch files, intermediate results, and automatic eviction of large tool outputs.

### FilesystemBackend (local disk)
- Reads/writes real files under a configurable `root_dir`.
- Optional `virtual_mode=True` to sandbox and normalize paths under `root_dir`.
- Uses secure path resolution, prevents unsafe symlink traversal when possible, can use ripgrep for fast `grep`.
- Best for local projects, CI sandboxes, or mounted persistent volumes.

### StoreBackend (LangGraph Store)
- Stores files in a LangGraph `BaseStore` provided by the runtime, enabling cross‑thread durable storage.
- Best when you already run with a configured LangGraph store (for example, Redis, Postgres, or cloud implementations behind `BaseStore`).


### CompositeBackend (router)
- Routes file operations to different backends based on path prefix.
- Preserves the original path prefixes in listings and search results.

## Specify a backend

- Pass a backend to `create_deep_agent(backend=...)`. The filesystem middleware uses it for all tooling.
- You can pass either:
  - An instance implementing `BackendProtocol` (for example, `FilesystemBackend(root_dir=".")`), or
  - A factory `BackendFactory = Callable[[ToolRuntime], BackendProtocol]` (for backends that need runtime like `StateBackend` or `StoreBackend`).
- If omitted, the default is `lambda rt: StateBackend(rt)`.


## Composite routing

Route parts of the namespace to different backends. Commonly used to persist `/memories/*` and keep everything else ephemeral.

Example (recommended):



Behavior:
- `/workspace/plan.md` → StateBackend (ephemeral)
- `/memories/agent.md` → FilesystemBackend under `~/.deepagents/myagent`
- `ls`, `glob`, `grep` aggregate results and show original path prefixes.

Notes:
- Longer prefixes win (for example, route `"/memories/projects/"` can override `"/memories/"`).
- For StoreBackend routing, ensure the agent runtime provides a store (`runtime.store`).

## Virtual filesystem: S3, Postgres, …

Build a custom backend to project a remote or database filesystem into the tools namespace.

Design guidelines:
- Paths are absolute (`/x/y.txt`). Decide how to map them to your storage keys/rows.
- Implement `ls_info` and `glob_info` efficiently (server‑side listing where available, otherwise local filter).
- Return user‑readable error strings for missing files or invalid regex patterns.
- For external persistence, set `files_update=None` in results; only in‑state backends should return a `files_update` dict.

S3‑style skeleton:



Postgres‑style outline:
- Table `files(path text primary key, content text, created_at timestamptz, modified_at timestamptz)`
- Map tool operations onto SQL:
  - `ls_info` uses `WHERE path LIKE $1 || '%'`
  - `glob_info` filter in SQL or fetch then apply glob in Python
  - `grep_raw` can fetch candidate rows by extension or last modified time, then scan lines

## Hooks and policy enforcement

Enforce enterprise rules by subclassing or wrapping a backend.

Block writes/edits under selected prefixes (subclass):



Generic wrapper (works with any backend):



## Protocol reference

Backends must implement the `BackendProtocol`.

Required endpoints:
- `ls_info(path: str) -> list[FileInfo]`
  - Return entries with at least `path`. Include `is_dir`, `size`, `modified_at` when available. Sort by `path` for deterministic output.
- `read(file_path: str, offset: int = 0, limit: int = 2000) -> str`
  - Return numbered content. On missing file, return `"Error: File '/x' not found"`.
- `grep_raw(pattern: str, path: Optional[str] = None, glob: Optional[str] = None) -> list[GrepMatch] | str`
  - Return structured matches. For an invalid regex, return a string like `"Invalid regex pattern: ..."` (do not raise).
- `glob_info(pattern: str, path: str = "/") -> list[FileInfo]`
  - Return matched files as `FileInfo` entries (empty list if none).
- `write(file_path: str, content: str) -> WriteResult`
  - Create‑only. On conflict, return `WriteResult(error=...)`. On success, set `path` and for state backends set `files_update={...}`; external backends should use `files_update=None`.
- `edit(file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult`
  - Enforce uniqueness of `old_string` unless `replace_all=True`. If not found, return error. Include `occurrences` on success.

Supporting types:
- `WriteResult(error, path, files_update)`
- `EditResult(error, path, files_update, occurrences)`
- `FileInfo` with fields: `path` (required), optionally `is_dir`, `size`, `modified_at`.
- `GrepMatch` with fields: `path`, `line`, `text`.

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/deepagents/backends.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
