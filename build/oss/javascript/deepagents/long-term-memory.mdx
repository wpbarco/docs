---
title: Long-term memory
description: Learn how to extend deep agents with persistent memory across threads
---

Deep agents come with a local filesystem to offload memory. This filesystem is stored in state and is therefore **transient to a single thread**â€”files are lost when the conversation ends.

You can extend deep agents with **long-term memory** by providing a LangGraph `Store` and setting `use_longterm_memory=True`. This enables persistent storage that survives across threads and conversations.

## Setup



```typescript
// TODO: Add JS implementation
```


## How it works

When long-term memory is enabled, deep agents maintain **two separate filesystems**:

### 1. Short-term (transient) filesystem
- Stored in the agent's state
- Persists only within a single thread
- Files are lost when the thread ends
- Accessed through standard paths: `/notes.txt`

### 2. Long-term (persistent) filesystem
- Stored in a LangGraph Store
- Persists across all threads and conversations
- Files survive indefinitely
- Accessed through the special prefix: `/memories/notes.txt`

## The /memories/ path convention

**The key to long-term memory is the `/memories/` path prefix:**

- Files with paths starting with `/memories/` are stored in the Store (persistent)
- Files without this prefix remain in transient state
- All filesystem tools (`ls`, `read_file`, `write_file`, `edit_file`) work with both



```typescript
// TODO: Add JS implementation
```


## Cross-thread persistence

Files in `/memories/` can be accessed from any thread:



```typescript
// TODO: Add JS implementation
```


## Use cases

### User preferences

Store user preferences that persist across sessions:



```typescript
// TODO: Add JS implementation
```


### Self-improving instructions

An agent can update its own instructions based on feedback:



```typescript
// TODO: Add JS implementation
```


Over time, the instructions file accumulates user preferences, helping the agent improve.

### Knowledge base

Build up knowledge over multiple conversations:



```typescript
// TODO: Add JS implementation
```


### Research projects

Maintain research state across sessions:



```typescript
// TODO: Add JS implementation
```


## Store implementations

Any LangGraph `BaseStore` implementation works:

### InMemoryStore (development)

Good for testing and development, but data is lost on restart:



```typescript
// TODO: Add JS implementation
```


### PostgresStore (production)

For production, use a persistent store:



```typescript
// TODO: Add JS implementation
```


## Best practices

### Use descriptive paths

Organize long-term files with clear, hierarchical paths:



### Document what gets persisted

In system prompts, clarify when to use long-term vs short-term storage:



### Isolate storage by assistant ID

For multi-tenant applications, provide an `assistant_id` to isolate storage:



Each assistant gets its own namespace in the Store, preventing cross-contamination.

### Use persistent stores in production



## Listing files

The `ls` tool shows files from both filesystems:



Files from the Store are prefixed with `/memories/` in listings.

## Limitations

### Store is required

You must provide a Store when enabling long-term memory:



### Agents must use correct paths

The agent must learn to use the `/memories/` prefix for persistence. The system prompt teaches this, but the agent must follow the instructions.

### No automatic cleanup

Long-term files persist indefinitely. There's no built-in TTL or automatic cleanup. You'll need to implement cleanup strategies if needed.

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/deepagents/long-term-memory.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
