---
title: Tools
---

import AlphaCallout from "/snippets/alpha-lc-callout.mdx";

<AlphaCallout />

Many AI applications interact with users via natural language. However, some use cases require models to interface directly with external systems—such as APIs, databases, or file systems—using structured input.

Tools are components that [agents](/oss/javascript/langchain/agents) call to perform actions. They extend model capabilities by letting them interact with the world through well-defined inputs and outputs. Tools encapsulate a callable function and its input schema. These can be passed to compatible [chat models](/oss/javascript/langchain/models), allowing the model to decide whether to invoke a tool and with what arguments. In these scenarios, tool calling enables models to generate requests that conform to a specified input schema.

## Create tools

### Basic tool definition



The simplest way to create a tool is by importing the `tool` function from the `langchain` package. You can use [zod](https://zod.dev/) to define the tool's input schema:

```ts
import { z } from "zod"
import { tool } from "langchain"

const searchDatabase = tool(
  ({ query, limit }) => `Found ${limit} results for '${query}'`,
  {
    name: "search_database",
    description: "Search the customer database for records matching the query.",
    schema: z.object({
      query: z.string().describe("Search terms to look for"),
      limit: z.number().describe("Maximum number of results to return"),
    }),
  }
);
```




## Use tools with agents

Agents go beyond simple tool binding by adding reasoning loops, state management, and multi-step execution.

<Tip>To see examples of how to use tools with agents, see [Agents](/oss/javascript/langchain/agents).</Tip>

## State, context, and memory

<AccordionGroup>


    <Accordion title="Accessing runtime context inside a tool">
        <Info>
            **`runtime`**: The execution environment of your agent, containing immutable configuration and contextual data that persists throughout the agent's execution (e.g., user IDs, session details, or application-specific configuration).
        </Info>


        Tools can access an agent's runtime context through the `config` parameter:

        ```ts wrap
        import { z } from "zod"
        import { ChatOpenAI } from "@langchain/openai"
        import { createAgent } from "langchain"

        const getUserName = tool(
          (_, config) => {
            return config.context.user_name
          },
          {
            name: "get_user_name",
            description: "Get the user's name.",
            schema: z.object({}),
          }
        );

        const contextSchema = z.object({
          user_name: z.string(),
        });

        const agent = createAgent({
          model: new ChatOpenAI({ model: "gpt-4o" }),
          tools: [getUserName],
          contextSchema,
        });

        const result = await agent.invoke(
          {
            messages: [{ role: "user", content: "What is my name?" }]
          },
          {
            context: { user_name: "John Smith" }
          }
        );
        ```

    </Accordion>

    <Accordion title="Accessing long-term memory inside a tool">
        <Info>
            **`store`**: LangChain's persistence layer. An agent's long-term memory store, e.g. user-specific or application-specific data stored across conversations.
        </Info>


        You can initialize an `InMemoryStore` to store long-term memory:

        ```ts wrap
        import { z } from "zod";
        import { createAgent, InMemoryStore } from "langchain";
        import { ChatOpenAI } from "@langchain/openai";

        const store = new InMemoryStore();

        const getUserInfo = tool(
          ({ user_id }) => {
            return store.get(["users"], user_id)
          },
          {
            name: "get_user_info",
            description: "Look up user info.",
            schema: z.object({
              user_id: z.string(),
            }),
          }
        );

        const agent = createAgent({
          model: new ChatOpenAI({ model: "gpt-4o" }),
          tools: [getUserInfo],
          store,
        });
        ```

    </Accordion>

    <Accordion title="Updating long-term memory inside a tool">
        To update long-term memory, you can use the `.put()` method of `InMemoryStore`. A complete example of persistent memory across sessions:



        ```ts wrap expandable
        import { z } from "zod";
        import { createAgent, tool } from "langchain";
        import { InMemoryStore } from "@langchain/langgraph";
        import { ChatOpenAI } from "@langchain/openai";

        const store = new InMemoryStore();

        const getUserInfo = tool(
          async ({ user_id }) => {
            const value = await store.get(["users"], user_id);
            console.log("get_user_info", user_id, value);
            return value;
          },
          {
            name: "get_user_info",
            description: "Look up user info.",
            schema: z.object({
              user_id: z.string(),
            }),
          }
        );

        const saveUserInfo = tool(
          async ({ user_id, name, age, email }) => {
            console.log("save_user_info", user_id, name, age, email);
            await store.put(["users"], user_id, { name, age, email });
            return "Successfully saved user info.";
          },
          {
            name: "save_user_info",
            description: "Save user info.",
            schema: z.object({
              user_id: z.string(),
              name: z.string(),
              age: z.number(),
              email: z.string(),
            }),
          }
        );

        const agent = createAgent({
          llm: new ChatOpenAI({ model: "gpt-4o" }),
          tools: [getUserInfo, saveUserInfo],
          store,
        });

        // First session: save user info
        await agent.invoke({
          messages: [
            {
              role: "user",
              content: "Save the following user: userid: abc123, name: Foo, age: 25, email: foo@langchain.dev",
            },
          ],
        });

        // Second session: get user info
        const result = await agent.invoke({
          messages: [
            { role: "user", content: "Get user info for user with id 'abc123'" },
          ],
        });

        console.log(result);
        // Here is the user info for user with ID "abc123":
        // - Name: Foo
        // - Age: 25
        // - Email: foo@langchain.dev
        ```

    </Accordion>
</AccordionGroup>

---

<Callout icon="pen-to-square" iconType="regular">
  [Edit the source of this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/tools.mdx)
</Callout>
