---
title: Tools
---

import AlphaCallout from "/snippets/alpha-lc-callout.mdx";

<AlphaCallout />

Many AI applications interact with users via natural language. However, some use cases require models to interface directly with external systems—such as APIs, databases, or file systems—using structured input.

Tools are components that [agents](/oss/python/langchain/agents) call to perform actions. They extend model capabilities by letting them interact with the world through well-defined inputs and outputs. Tools encapsulate a callable function and its input schema. These can be passed to compatible [chat models](/oss/python/langchain/models), allowing the model to decide whether to invoke a tool and with what arguments. In these scenarios, tool calling enables models to generate requests that conform to a specified input schema.

## Create tools

### Basic tool definition

The simplest way to create a tool is with the `@tool` decorator. By default, the function's docstring becomes the tool's description that helps the model understand when to use it:

```python wrap
from langchain.tools import tool

@tool
def search_database(query: str, limit: int = 10) -> str:
    """Search the customer database for records matching the query.

    Args:
        query: Search terms to look for
        limit: Maximum number of results to return
    """
    return f"Found {limit} results for '{query}'"
```

Type hints are **required** as they define the tool's input schema. The docstring should be informative and concise to help the model understand the tool's purpose.




### Customize tool properties

#### Custom tool name

By default, the tool name comes from the function name. Override it when you need something more descriptive:

```python wrap
@tool("web_search")  # Custom name
def search(query: str) -> str:
    """Search the web for information."""
    return f"Results for: {query}"

print(search.name)  # web_search
```

#### Custom tool description

Override the auto-generated tool description for clearer model guidance:

```python wrap
@tool("calculator", description="Performs arithmetic calculations. Use this for any math problems.")
def calc(expression: str) -> str:
    """Evaluate mathematical expressions."""
    return str(eval(expression))
```

### Advanced schema definition

Define complex inputs with Pydantic models or JSON schemas:

<CodeGroup>
    ```python wrap Pydantic model
    from pydantic import BaseModel, Field
    from typing import Literal

    class WeatherInput(BaseModel):
        """Input for weather queries."""
        location: str = Field(description="City name or coordinates")
        units: Literal["celsius", "fahrenheit"] = Field(
            default="celsius",
            description="Temperature unit preference"
        )
        include_forecast: bool = Field(
            default=False,
            description="Include 5-day forecast"
        )

    @tool(args_schema=WeatherInput)
    def get_weather(location: str, units: str = "celsius", include_forecast: bool = False) -> str:
        """Get current weather and optional forecast."""
        temp = 22 if units == "celsius" else 72
        result = f"Current weather in {location}: {temp} degrees {units[0].upper()}"
        if include_forecast:
            result += "\nNext 5 days: Sunny"
        return result
    ```

    ```python wrap JSON Schema
    weather_schema = {
        "type": "object",
        "properties": {
            "location": {"type": "string"},
            "units": {"type": "string"},
            "include_forecast": {"type": "boolean"}
        },
        "required": ["location", "units", "include_forecast"]
    }

    @tool(args_schema=weather_schema)
    def get_weather(location: str, units: str = "celsius", include_forecast: bool = False) -> str:
        """Get current weather and optional forecast."""
        temp = 22 if units == "celsius" else 72
        result = f"Current weather in {location}: {temp} degrees {units[0].upper()}"
        if include_forecast:
            result += "\nNext 5 days: Sunny"
        return result
    ```
</CodeGroup>


## State, context, and memory

<AccordionGroup>
    <Accordion title="Accessing agent state inside a tool">
        <Info>
            **`state`**: The agent maintains state throughout its execution - this includes messages, custom fields, and any data your tools need to track. State flows through the graph and can be accessed and modified by tools.
        </Info>

        <Info>
            **`InjectedState`**: An annotation that allows tools to access the current graph state without exposing it to the LLM. This lets tools read information like message history or custom state fields while keeping the tool's schema simple.
        </Info>

        Tools can access the current graph state using the `InjectedState` annotation:

        ```python wrap
        from typing_extensions import Annotated
        from langchain.tools import InjectedState

        # Access the current conversation state
        @tool
        def summarize_conversation(
            state: Annotated[dict, InjectedState]
        ) -> str:
            """Summarize the conversation so far."""
            messages = state["messages"]

            human_msgs = sum(1 for m in messages if m.__class__.__name__ == "HumanMessage")
            ai_msgs = sum(1 for m in messages if m.__class__.__name__ == "AIMessage")
            tool_msgs = sum(1 for m in messages if m.__class__.__name__ == "ToolMessage")

            return f"Conversation has {human_msgs} user messages, {ai_msgs} AI responses, and {tool_msgs} tool results"

        # Access custom state fields
        @tool
        def get_user_preference(
            pref_name: str,
            preferences: Annotated[dict, InjectedState("user_preferences")]  # InjectedState parameters are not visible to the model
        ) -> str:
            """Get a user preference value."""
            return preferences.get(pref_name, "Not set")
        ```

        <Warning>
            State-injected arguments are hidden from the model. For the example above, the model only sees `pref_name` in the tool schema - `preferences` is *not* included in the request.
        </Warning>
    </Accordion>

    <Accordion title="Updating agent state inside a tool">
        <Info>
        **`Command`**: A special return type that tools can use to update the agent's state or control the graph's execution flow. Instead of just returning data, tools can return `Command`s to modify state or direct the agent to specific nodes.
        </Info>

        Use a tool that returns a `Command` to update the agent state:

        ```python wrap
        from langgraph.types import Command
        from langchain.messages import RemoveMessage
        from langgraph.graph.message import REMOVE_ALL_MESSAGES
        from langchain.tools import tool, InjectedToolCallId
        from typing_extensions import Annotated

        # Update the conversation history by removing all messages
        @tool
        def clear_conversation() -> Command:
            """Clear the conversation history."""

            return Command(
                update={
                    "messages": [RemoveMessage(id=REMOVE_ALL_MESSAGES)],
                }
            )

        # Update the user_name in the agent state
        @tool
        def update_user_name(
            new_name: str,
            tool_call_id: Annotated[dict, InjectedToolCallId]
        ) -> Command:
            """Update the user's name."""
            return Command(update={"user_name": new_name})
        ```
    </Accordion>


    <Accordion title="Accessing runtime context inside a tool">
        <Info>
            **`runtime`**: The execution environment of your agent, containing immutable configuration and contextual data that persists throughout the agent's execution (e.g., user IDs, session details, or application-specific configuration).
        </Info>

        Tools can access an agent's runtime context through `get_runtime`:

        ```python wrap
        from dataclasses import dataclass
        from langchain_openai import ChatOpenAI
        from langchain.agents import create_agent
        from langchain.tools import tool
        from langgraph.runtime import get_runtime

        USER_DATABASE = {
            "user123": {
                "name": "Alice Johnson",
                "account_type": "Premium",
                "balance": 5000,
                "email": "alice@example.com"
            },
            "user456": {
                "name": "Bob Smith",
                "account_type": "Standard",
                "balance": 1200,
                "email": "bob@example.com"
            }
        }

        @dataclass
        class UserContext:
            user_id: str

        @tool
        def get_account_info() -> str:
            """Get the current user's account information."""
            runtime = get_runtime(UserContext)
            user_id = runtime.context.user_id

            if user_id in USER_DATABASE:
                user = USER_DATABASE[user_id]
                return f"Account holder: {user['name']}\nType: {user['account_type']}\nBalance: ${user['balance']}"
            return "User not found"

        model = ChatOpenAI(model="gpt-4o")
        agent = create_agent(
            model,
            tools=[get_account_info],
            context_schema=UserContext,
            system_prompt="You are a financial assistant."
        )

        result = agent.invoke(
            {"messages": [{"role": "user", "content": "What's my current balance?"}]},
            context=UserContext(user_id="user123")
        )
        ```


    </Accordion>

    <Accordion title="Accessing long-term memory inside a tool">
        <Info>
            **`store`**: LangChain's persistence layer. An agent's long-term memory store, e.g. user-specific or application-specific data stored across conversations.
        </Info>

        Tools can access an agent's store through `get_store`:

        ```python wrap
        from langgraph.config import get_store

        @tool
        def get_user_info(user_id: str) -> str:
            """Look up user info."""
            store = get_store()
            user_info = store.get(("users",), user_id)
            return str(user_info.value) if user_info else "Unknown user"
        ```


    </Accordion>

    <Accordion title="Updating long-term memory inside a tool">
        To update long-term memory, you can use the `.put()` method of `InMemoryStore`. A complete example of persistent memory across sessions:

        ```python wrap expandable
        from typing import Any
        from langgraph.config import get_store
        from langgraph.store.memory import InMemoryStore
        from langchain.agents import create_agent
        from langchain.tools import tool

        @tool
        def get_user_info(user_id: str) -> str:
            """Look up user info."""
            store = get_store()
            user_info = store.get(("users",), user_id)
            return str(user_info.value) if user_info else "Unknown user"

        @tool
        def save_user_info(user_id: str, user_info: dict[str, Any]) -> str:
            """Save user info."""
            store = get_store()
            store.put(("users",), user_id, user_info)
            return "Successfully saved user info."

        store = InMemoryStore()
        agent = create_agent(
            model,
            tools=[get_user_info, save_user_info],
            store=store
        )

        # First session: save user info
        agent.invoke({
            "messages": [{"role": "user", "content": "Save the following user: userid: abc123, name: Foo, age: 25, email: foo@langchain.dev"}]
        })

        # Second session: get user info
        agent.invoke({
            "messages": [{"role": "user", "content": "Get user info for user with id 'abc123'"}]
        })
        # Here is the user info for user with ID "abc123":
        # - Name: Foo
        # - Age: 25
        # - Email: foo@langchain.dev
        ```



    </Accordion>
</AccordionGroup>

---

<Callout icon="pen-to-square" iconType="regular">
  [Edit the source of this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/tools.mdx)
</Callout>
